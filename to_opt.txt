Текущая реализация - записи считываются последовательно, отдельные поля перекодируются

Цель - создание кэша объектов для минимизации числа обращений к БД. Нужно оптимизировать процедуру загрузки по времени на БД с плохим IO
Вариант реализации - читать данные порциями, считывать в кэш коллекции связанных объектов, формировать резальтирующие данные, потом вставлять с ускорителями.


Кэш работает в двух режимах - потоковый и пакетный. Сначала реализуем пакетный, потоковый по необходимости.
В пакетном режиме сначала формируется список ID записей через последовательность вызовов процедуры ..
При каждом вызове процедура проверяет уникальность переданного ID, после через добавляет его в список. Если ID уже есть в списке, 
никаких действий не требуется.
Затем в процедуре массового заполнения кэша все записи из списка в пакетной загрузке читаются в коллекцию.
Дальше два варианта - либо коллекция остается и процедура чтения каждый раз перебирает ее, отыскивая нужный элемент,
либо она преобразуется в ассоциативный массив с индексацией по ID. После этого в целом процедура чтения не нужна. 
Надо оценить расходы в обоих вариантах.   

Предусмотреть отключаемое логирование для оценки производительности, завязать на атрибут.

подумать насчет таблицы REPLOBJ - к ней будет слишком много обращений.

в объекте должны быть
0. очистка данных 
1. чтение одной записи
2. добавление записи по ID, забивает в последовательность через дистинкт
* 3. добавление набора записей через список int ID. 
* 4. добавление набора записей через список str ID?

5. атрибут отложенной загрузки. 
6. метод массовой загрузки кэша. Результат - коллекция ошибок. и флаг, всё ли загрузилось
7. атрибут лимита кэша
8. атрибут текущего количества записей.

11. переопределяемая запись - единица хранения
12. переопределяемые курсоры в заголовке для чтения данных
9. переопределяемый метод единичной загрузки - меняются типы
10. переопределяемый метод массовой загрузки - меняются типы